学习笔记

#### Part 深度优先 广度优先

##### 括号生成问题

​	又遇括号生成问题，从本节内容来看，括号生成问题是一种广度优先搜索，每次下探有两种选择：'(',')'。 每次下探的时候要关注是否合法

##### 二叉树的层序遍历

​	bfs + 判断处于哪一层 每次用node暂存当前节点，queue=node传递节点信息

​	dfs 也可以 因为dfs有层间信息

#### Part 贪心算法

##### 买卖股票的最佳时机

​	使用贪心思路简化，只要前一天比后一天小，就买入并在后一天抛。

##### 跳跃游戏

​	遍历所有可以到达的数组元素，找到当前元素条件下可到的最远距离，最后看最大最远距离是否大于数组长度。

​	eg：[2,3,1,1,4] 

​			i ==0 temp_max_dist = 0 + 2

​			i == 1 temp_max_dist = 1 + 3

##### 分发饼干

​	对两个数组sort `g.sort(), s.sort()`，得到递增数列。胃口数列是从小到大，我们依次遍历，由最小的胃口开始满足。

​	如果满足`if g[i] <= s[j]:`继续向下遍历，res+1.

​	如果不满足 `else:j += 1`  饼干指针向下走

#### Part 二分查找

**使用条件：1.单调；2.有界；3.可以用索引**

##### 搜索旋转排列数组

​	1. 判断mid的处境，两种情况

​		[6, 7, 0, 1, 2, 4, 5]	——   mid<nums[0] : 后方是有序的

​		[2, 3, 4, 5, 6, 7, 1]	——   mid<nums[0] : 前方是有序的

2. 确定哪一边有序后，判断target是否在有序数组中。

 	3. 注意条件中的等于号，用来搞定target==边界元素的情况。

#####  使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方。同学们可以将自己的思路、代码写在学习总结中 

​	套用模版，找到mid，mid和头尾元素比，确定哪边数组是有序的，若右侧有序，则再比较mid+1和尾元素。如果mid+1和尾元素构成递增数组，则找到。否则在后方找。

```
def find_no_order(t_l):
	left, right = 0, len(t_l)
	mid = (left+right) //2
	while left <= right:
		if t_l[mid] > t_l[0]:
			if t_l[mid+1] < t_l[-1]:
				return mid, mid+1
			else: # 向右找
				left = mid + 1
		else:
			if t_l[mid-1] > t_l[0]:
				return mid-1, mid
			else:	# 向左找
				right = mid -1
	return -1
				
				
```

